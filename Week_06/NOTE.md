# 动态规划学习笔记
## 概念
动态规划，Dynamic Programming，其核心思想是把原问题分解成子问题进行求解，也就是分治的思想。
### 多阶段决策过程的最优化问题
把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为多阶段决策问题。在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。当然，各个阶段决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展，当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。
## 特点
动态规划与分治和递归并无本质上的区别，共性为找到重复子问题，差异点在于动态规划是一种最优子结构的形式，中途可以淘汰次优解。

## 递归代码模版
```
//递归终止条件terminator
if(level>max_value){
	return;
}
//处理当前层逻辑process current logic
process(level,param)
//下探到下一层drill down
recur(level:level+1,new param)
//restore current status

```
## 思考过程

### 1.划分状态
即划分子问题，例如上面的例子，我们可以认为每个组下面、每个部门、每个中心下面最优秀的3个人，都是全公司最优秀的3个人的子问题
### 2.状态表示
即如何让计算机理解子问题。上述例子，我们可以实用f[i][3]表示第i个人，他手下最优秀的3个人是谁。
### 3.状态转移
即父问题是如何由子问题推导出来的。上述例子，每个人大Leader下面最优秀的人等于他下面的小Leader中最优秀的人中最优秀的几个。
### 4.确定边界
确定初始状态是什么？最小的子问题？最终状态又是什么。例如上述问题，最小的子问题就是每个小组长下面最优秀的人，最终状态是整个企业，初始状态为每个领导下面都没有最优名单，但是小组长下面拥有每个人的评分。
## 经典模型
### 1.线性模型
最经典的问题就是斐波那楔数列的问题，每个数的值都是一个状态，可以用F[i]表示表示第i个数的值是多少。每个数都是由F[i-1]+F[i-2]转移而来。从左往右，从上到下，从低维到高维进行转移。
### 2.区间模型
对于每个问题，都是由子区间推导过来的，我们称之为区间模型。
#### 例
我们有一个连续的序列，每个序列上面都是一个数字c[i]，每次我们都能够消灭一个连续的回文子序列，消灭之后左右会合并，成为一个新序列，问最少需要多少次才能够把整个序列消灭掉。回文就是从左到有从右到左读到的序列都是一样的。题目比较抽象，我们通过一些例子来说明这个问题吧？例如一开始的序列是1 4 4 2 3 2 1，那么我们最少需要2次，先消灭掉4 4 ， 然后再消灭调1 2 3 2 1.第二个例子是 1 2 3 4 5 5 3 1，我们先消灭掉2 然后再消灭掉4， 最后消灭 1 3 5 5 3 1， 需要3次。
### 3.树状模型
我们在数据结构树上面进行最求最优解、最大值等问题，上述我们讲的这个绩效考核就是一个树状模型，具体不再累叙。
## 实现的套路
一个是自底向上，另外一个是自顶向下。都要明确动态规划的过程，把状态表示、状态转移、边界都考虑好。
### 1.自底向上
简单来说就是根据初始状态，逐步推导到最终状态，而这个转移的过程，必定是一个拓扑序。可以轻松确定拓扑序的问题，例如线性模型，都是从左往右进行转移，区间模型，一般都是从小区间推导到大区间。自底向上的一个经典实现是斐波那楔数列的递推实现，即F[i] = F[i - 1] + F[i - 2] 。

### 2.自顶向下
也就是从最终状态出发，如果遇到一个子问题还未求解，那么就先求解子问题。如果子问题已经求解，那么直接使用子问题的解，所以自顶向下动态规划又有一个形象生动的名字，叫做记忆化搜索，一般我们采用递归的方式进行求解。